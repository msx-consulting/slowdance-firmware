// Â©2017 Wonder Machines

// Authored by
// - Josh Gordonson
// - Owen Trueblood
// - Jeff Lieberman

#include <math.h>
#include "avr/pgmspace.h"

#include "util.h"

// This gets generated by a script which calculates the PDM approximation of a waveform
// Run "make" in the sketch directory if it's missing
#include "waveform.h"

// Set to 8MHz (even if board.txt incorrect)
#ifdef F_CPU
#undef F_CPU
#endif
#define F_CPU 8000000 // 8 MHz

// Pin definitions
const int PIN_ENABLE = PD7;
const int PIN_COIL1 = PD4;
const int PIN_COIL2 = PD5;
const int PIN_LIGHT = PB2;
const int PIN_MODE_BUTTON = PC0;
const int PIN_BRIGHTNESS_POT = PC1;

// Timer0 is used to drive the electromagnet with pulse density modulation.

// Here we calculate the TOP value needed to fire interrupt for each PDM sample
// PDM_TARGET_FREQUENCY is defined in waveform.h which is generated by
// generate_waveform.py in addition to the waveform samples

const int TIMER0_PRESCALE = 1;
const int TIMER_TOP_PDM = (int)(
  (double) F_CPU /
    ((double) TIMER0_PRESCALE * (double) PDM_TARGET_FREQUENCY * 2.0)
  - 1.0);

static_assert(TIMER_TOP_PDM > 0, "PDM frequency too high. Maybe reduce prescaler?");
static_assert(TIMER_TOP_PDM < 256, "PDM frequency too low for (8 bit) Timer0. Maybe increase prescaler?");

const uint8_t TIMER0_CLOCK_BITS = 1;

// Timer1 is used to drive the strobe light at varying frequencies
// The zeropoint matches the frequencies of the strobe and the electromagnet so
// the object appears to be still.

const int TIMER1_PRESCALE = 8;
const int ZEROPOINT = (long) TIMER_TOP_PDM * (WAVEFORM_SIZE + 1) / TIMER1_PRESCALE * 2;

volatile int strobeWait = ZEROPOINT;
volatile int strobeBrightness = 100; // Length of strobe = brightness
unsigned int cycleCounter = 0; // How many cycles we have completed
unsigned int buttonDisableTimer = 0;

// Length of time the button is disabled after being pressed
const int BUTTON_DISABLE_TICKS = 40; // Cycles @ 80 Hz

// Mode adjustment / button:
typedef enum AnimationMode {
#ifdef DEBUG
  ANIM_FREEZE,
#endif
  ANIM_SLOW,
  ANIM_MEDIUM,
  ANIM_POPLOCK,
  ANIM_DOUBLER,
  ANIM_OFF,
#ifdef DEBUG
  ANIM_FIRST = ANIM_FREEZE,
#else
  ANIM_FIRST = ANIM_SLOW,
#endif
  ANIM_LAST = ANIM_OFF,
} AnimationMode;

AnimationMode currentAnimationMode = ANIM_FIRST;

volatile boolean cycleStart = true;

// Electromagnet interrupt

volatile int outputIndex = 0;

ISR(TIMER0_COMPA_vect) { // Use pin D6 as PWM to control D4 and D5
  uint8_t sample = pgm_read_byte_near(waveform + outputIndex++);

  if (sample) {
    PORTD &= ~(1 << PIN_COIL1);
    PORTD |= (1 << PIN_COIL2);
  } else {
    PORTD |= (1 << PIN_COIL1);
    PORTD &= ~(1 << PIN_COIL2);
  }

  if (outputIndex > WAVEFORM_SIZE) {
    outputIndex = 0;
  }
}

// Light strobe interrupt
volatile unsigned int strobeTimer = 0;
ISR(TIMER1_COMPB_vect) {
  // Generate a PWM signal in CTC mode "by hand" for light
  if (strobeTimer % 2 == 0) {
    OCR1A = strobeWait - strobeBrightness;
    cycleStart = true;

    // Set OC1B (PIN_LIGHT) on compare match
    TCCR1A |= (3 << COM1B0);
  } else {
    // Keep light on for strobeBrightness timer ticks
    OCR1A = strobeBrightness;

    // Clear OC1B (PIN_LIGHT) on compare match
    TCCR1A &= ~(1 << COM1B0);
    TCCR1A |= (2 << COM1B0);
  }

  strobeTimer++;
}

void setBrightness() {
  ADCSRA |= (1 << ADSC); // Start an ADC conversion
  while (ADCSRA & (1 << ADSC)) {} // Wait for the conversion to end
  strobeBrightness = 1 * (0x3ff - ADC) + 100; // Calculate brightness
}

void gotoNextMode() {
  switch (currentAnimationMode) {
#ifdef DEBUG
    case ANIM_FREEZE:
      currentAnimationMode = ANIM_SLOW;
      break;
#endif
    case ANIM_SLOW:
      currentAnimationMode = ANIM_MEDIUM;
      break;
    case ANIM_MEDIUM:
      currentAnimationMode = ANIM_POPLOCK;
      break;
    case ANIM_POPLOCK:
      currentAnimationMode = ANIM_DOUBLER;
      break;
    case ANIM_DOUBLER:
      currentAnimationMode = ANIM_OFF;
      stopDancing();
      break;
    case ANIM_OFF:
#ifndef DEBUG
      currentAnimationMode = ANIM_SLOW;
#else
      currentAnimationMode = ANIM_FREEZE;
#endif
      startDancing();
      break;
  }
}

void handleModeChange() {
  bool buttonDisabled = buttonDisableTimer < BUTTON_DISABLE_TICKS;

  if (buttonDisabled) {
    return;
  }

  // Pressing the button pulls down this pin (it is inverted)
  bool buttonPressed = !(PINC & (1 << PIN_MODE_BUTTON));

  if (buttonPressed) {
    gotoNextMode();

    // Disable the button for a while
    buttonDisableTimer = 0;
  }
}

float calculateWaitFromMode() {
  switch (currentAnimationMode) {
#ifdef DEBUG
    case ANIM_FREEZE: {
      return ZEROPOINT;
    }
#endif
    case ANIM_SLOW: {
      return ZEROPOINT + 20.0;
    }
    case ANIM_MEDIUM: {
      return ZEROPOINT + 50.0;
    }
    case ANIM_POPLOCK: {
      static int zpt = ZEROPOINT;
      static int poplockCounter = 0;

      if(poplockCounter++ == 18) {
        poplockCounter = 0;
        return zpt * 1.025;
      }

      return zpt;
    }
    case ANIM_DOUBLER: {
      strobeBrightness /= 2;
      float animationPhase = (float)cycleCounter / 3000.0f;
      return ZEROPOINT * 0.5 + 35.0 * sin(animationPhase);
    }
    case ANIM_OFF: {
      // Turning off electromagnet and strobe is done at the transition (in gotoNextMode)
      return ZEROPOINT;
    }
    default: {
      // No motion
      return ZEROPOINT;
    }
  }
}

void startDancing() {
  // Enable electromagnet drive
  TCCR0B |= (TIMER0_CLOCK_BITS << CS00); // Phase correct mode, clk/1, start the clock!
  PORTD |= (1 << PIN_ENABLE); // Enable H bridge driver for electromagnet

  // Enable light strobing
  PORTB |= (1 << PIN_LIGHT);
  DDRB |= (1 << PIN_LIGHT);
}

void stopDancing() {
  // Disable electromagnet drive
  TCCR0B &= ~(1 << CS01); // Phase correct mode, clk/1, start the clock!
  PORTD &= ~(1 << PIN_ENABLE);

  // Disable light strobing
  DDRB &= ~(1 << PIN_LIGHT);
  PORTB &= ~(1 << PIN_LIGHT);
}

void setupTimers() {
  // Setup Timer0 interrupt for driving the electromagnet
  OCR0A = TIMER_TOP_PDM;
  TCCR0A = (1 << WGM00);
  // TCCR0B = (1 << CS01) | (1 << WGM02); // Phase correct mode, clk/8, start the clock!
  TCCR0B = (TIMER0_CLOCK_BITS << CS00) | (1 << WGM02); // Phase correct mode, clk/1, start the clock!
  TIMSK0 = (1 << OCIE0A); // Enable compare A interrupt

  // Setup Timer1 interrupt for driving the light at 80Hz
  TIMSK1 = (1 << OCIE1B); // Enable compare B match interrupt
  TCCR1A = 0; // Normal port operation
  TCCR1B = (1 << WGM12) | (1 << CS11); // CTC mode, clk/8

  startDancing();

  sei();
}

void setup() {
  cli();

  // Output pins
  DDRD |= (1 << PIN_COIL1) | (1 << PIN_COIL2) | (1 << PIN_ENABLE);
  DDRB |= (1 << PIN_LIGHT);

  // Input pins
  DDRC &= ~((1 << PIN_MODE_BUTTON) | (1 << PIN_BRIGHTNESS_POT));
  PORTC |= (1 << 0);//PIN_MODE_BUTTON); // Pull-up the mode button
  DIDR0 = (1 << ADC1D); // Disable digital input buffer for the analog (brightness) input

  // Setup ADC
  ADMUX = (1 << REFS0) | (0 << ADLAR) | (1 << MUX0); // VCC/5v ref, right adjust, connect ADC0
  ADCSRA = (1 << ADEN) | (1 << ADSC) | (1 << ADPS1); // ADC clock: clk/4, enable

  // Start with light off
  PORTB &= ~(1 << PIN_LIGHT);

  // Set all unused pins as inputs with pull-ups
  DDRC &= ~((1 << PC2) | (1 << PC3) | (1 << PC4) | (1 << PC5));
  DDRD &= ~((1 << PD2) | (1 << PD3) | (1 << PD6));

  PORTC |= ((1 << PC2) | (1 << PC3) | (1 << PC4) | (1 << PC5));
  PORTD |= ((1 << PD2) | (1 << PD3) | (1 << PD6));

  // Aditional unconnected pins as inputs with pull-ups
  DDRB &= ~((1 << PB0) | (1 << PB1) | (1 << PB3) | (1 << PB4) | (1 << PB5));
  DDRD &= ~((1 << PD0) | (1 << PD1));

  PORTB |= ((1 << PB0) | (1 << PB1) | (1 << PB3) | (1 << PB4) | (1 << PB5));
  PORTD |= ((1 << PD0) | (1 << PD1));

  setupTimers();
}

void loop() {
  // Goal: Generate a cycle only once per strobe, always
  // Method: Set a flag in the PWM timer interrupt when the light turns on and check it here
  if (cycleStart) {
    cycleCounter++;

    setBrightness();
    handleModeChange();

    // Determine strobe delay time from current animation mode
    strobeWait = int(calculateWaitFromMode());

    // Tick the button disable timer if it's less than the timeout
    if (buttonDisableTimer < BUTTON_DISABLE_TICKS) {
      buttonDisableTimer++;
    }

    // Clear the flag so it can be set again on the start of the next cycle by the timer interrupt
    cycleStart = false;
  }
}
